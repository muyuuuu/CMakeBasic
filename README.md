# Intro

作为一个练习时长 6 年多的 `python` 程序员，面对工程时写好 `__init__.py` 直接导包就可以使用，命令行一句 `python main.py` 原地起飞。

自从转到 `C/C++`，竟然还要头文件，还要链接库，要写 `MakeFile` 手动把工程给组织起来，直接 `g++ main.cpp` 竟然不行！！！还有王法吗？？？这让初入门的我一度怀疑人生。

所以本仓库诞生了：通过几个由浅入深、层层递进的小例子，让没接触过 `CMake` 或者没写过 `C/C++` 工程的人快速上手。

由于 `CMake` 的写法高度依赖项目和文件夹的结构，所以在每个示例中会给出详细的介绍。

# 示例

|  | 项目 | 备注 |
| :--: |:--: |:--: |
| 0 | demo0 | 介绍为何使用 `CMake` |
| 1 | demo1 | 入门示例，其他文件中定义函数，在 `main.cpp` 中引用 |
| 2 | demo2 | 批量引用源文件，在 `main.cpp` 中引用 |
| 3 | demo3 | 初步工程化，更好的引用头文件和代码文件 |
| 4 | demo4 | 生成动/静态链接库 |
| 5 | demo5 | 使用动/静态链接库 |
| 6 | demo6 | 特殊宏定义 |
| 7 | demo7 | 一个含有加载库、自动化测试、日志输出多级目录的小项目，从此之后 `cmake` 问题不大 |

# 参考

1. https://subingwen.cn/cmake/CMake-primer/


动态库的链接具有传递性，如果动态库 A 链接了动态库B、C，动态库D链接了动态库A，此时动态库D相当于也链接了动态库B、C，并可以使用动态库B、C中定义的方法。

动态库的链接和静态库是完全不同的：

静态库会在生成可执行程序的链接阶段被打包到可执行程序中，所以可执行程序启动，静态库就被加载到内存中了。
动态库在生成可执行程序的链接阶段不会被打包到可执行程序中，当可执行程序被启动并且调用了动态库中的函数的时候，动态库才会被加载到内存
因此，在cmake中指定要链接的动态库的时候，应该将命令写到生成了可执行文件之后：
